// Copyright (c) 2004-2021 Microchip Technology Inc. and its subsidiaries.
// SPDX-License-Identifier: MIT

/* Generation Tag is temp */

/* ================================================================= *
 *               Note: This code is autogenerated from the
 *                     Universal Tcl Environment (UTE) which provides
 *                     consistent setup functions for
 *       ^             - Verification
 *      / \            - Validation
 *     /   \           - Test Pattern Generation and
 *    /  |  \          - Software
 *   /   !   \         It should not be modified manually.
 *  /_________\
 * ================================================================= */

#ifndef _VTSS_MASERATI__API_SD6G40_UTE
#define _VTSS_MASERATI__API_SD6G40_UTE

#include <vtss/api/options.h>  // To get the ARCH define
#if defined(VTSS_ARCH_LAN966X) && !defined(VTSS_OPT_FPGA)
#include "vtss_lan966x_cil.h"

static vtss_rc vtss_maserati_sd6g40_reg_cfg(vtss_state_t *vtss_state, vtss_sd6g40_setup_struct_t *const res_struct, u32 idx) {
    vtss_rc rc = VTSS_RC_OK;
    u32 value;

/* Note: SerDes HSIO is configured in 1G_LAN mode */
    REG_WRM(HSIO_SD_CFG(idx),
            HSIO_SD_CFG_LANE_10BIT_SEL(res_struct->lane_10bit_sel[0]) |
            HSIO_SD_CFG_RX_RATE(res_struct->rx_rate[0]) |
            HSIO_SD_CFG_TX_RATE(res_struct->tx_rate[0]) |
            HSIO_SD_CFG_TX_INVERT(res_struct->tx_invert[0]) |
            HSIO_SD_CFG_RX_INVERT(res_struct->rx_invert[0]) |
            HSIO_SD_CFG_LANE_LOOPBK_EN(res_struct->lane_loopbk_en[0]) |
            HSIO_SD_CFG_RX_RESET(0) |
            HSIO_SD_CFG_TX_RESET(0),
            HSIO_SD_CFG_LANE_10BIT_SEL_M |
            HSIO_SD_CFG_RX_RATE_M |
            HSIO_SD_CFG_TX_RATE_M |
            HSIO_SD_CFG_TX_INVERT_M |
            HSIO_SD_CFG_RX_INVERT_M |
            HSIO_SD_CFG_LANE_LOOPBK_EN_M |
            HSIO_SD_CFG_RX_RESET_M |
            HSIO_SD_CFG_TX_RESET_M);

    REG_WRM(HSIO_MPLL_CFG(idx),
            HSIO_MPLL_CFG_MPLL_MULTIPLIER(res_struct->mpll_multiplier[0]) |
            HSIO_MPLL_CFG_REF_CLKDIV2(res_struct->ref_clkdiv2[0]),
            HSIO_MPLL_CFG_MPLL_MULTIPLIER_M |
            HSIO_MPLL_CFG_REF_CLKDIV2_M);

    REG_WRM(HSIO_SD_CFG2(idx),
            HSIO_SD_CFG2_RX_EQ(res_struct->rx_eq[0]),
            HSIO_SD_CFG2_RX_EQ_M);

    REG_WRM(HSIO_SD_CFG2(idx),
            HSIO_SD_CFG2_TX_PREEMPH(res_struct->tx_preemp[0]),
            HSIO_SD_CFG2_TX_PREEMPH_M);

    REG_WRM(HSIO_SD_CFG(idx),
            HSIO_SD_CFG_RX_TERM_EN(res_struct->rx_term_en[0]),
            HSIO_SD_CFG_RX_TERM_EN_M);

    REG_WRM(HSIO_MPLL_CFG(idx),
            HSIO_MPLL_CFG_REF_SSP_EN(1),
            HSIO_MPLL_CFG_REF_SSP_EN_M);

    VTSS_NSLEEP(1000);

    REG_WRM(HSIO_SD_CFG(idx),
            HSIO_SD_CFG_PHY_RESET(0),
            HSIO_SD_CFG_PHY_RESET_M);

    VTSS_NSLEEP(10);

    REG_WRM(HSIO_MPLL_CFG(idx),
            HSIO_MPLL_CFG_MPLL_EN(1),
            HSIO_MPLL_CFG_MPLL_EN_M);

    VTSS_NSLEEP(7000);

    REG_RD(HSIO_SD_STAT(idx), &value);
    value = HSIO_SD_STAT_MPLL_STATE_X(value);
    if(value != 0x1) {
        VTSS_E("The expected value for sd_sd_stat mpll_state was 0x1 but is 0x%x", value);
        rc = VTSS_RC_ERROR;
    } else {
        VTSS_D("Note: The value of sd_sd_stat mpll_state was 0x%x", value);
    }

    REG_WRM(HSIO_SD_CFG(idx),
            HSIO_SD_CFG_TX_CM_EN(1),
            HSIO_SD_CFG_TX_CM_EN_M);

    VTSS_NSLEEP(230000);

    REG_RD(HSIO_SD_STAT(idx), &value);
    value = HSIO_SD_STAT_TX_CM_STATE_X(value);
    if(value != 0x1) {
        VTSS_E("The expected value for sd_sd_stat tx_cm_state was 0x1 but is 0x%x", value);
        rc = VTSS_RC_ERROR;
    } else {
        VTSS_D("Note: The value of sd_sd_stat tx_cm_state was 0x%x", value);
    }

    REG_WRM(HSIO_SD_CFG(idx),
            HSIO_SD_CFG_RX_PLL_EN(1) |
            HSIO_SD_CFG_TX_EN(1),
            HSIO_SD_CFG_RX_PLL_EN_M |
            HSIO_SD_CFG_TX_EN_M);

    VTSS_NSLEEP(4000);

/* Waiting for serdes 0 rx DPLL to lock...  */
    REG_RD(HSIO_SD_STAT(idx), &value);
    value = HSIO_SD_STAT_RX_PLL_STATE_X(value);
    if(value != 0x1) {
        VTSS_E("The expected value for sd_sd_stat rx_pll_state was 0x1 but is 0x%x", value);
        rc = VTSS_RC_ERROR;
    } else {
        VTSS_D("Note: The value of sd_sd_stat rx_pll_state was 0x%x", value);
    }

/* Waiting for serdes 0 tx operational...  */
    REG_RD(HSIO_SD_STAT(idx), &value);
    value = HSIO_SD_STAT_TX_STATE_X(value);
    if(value != 0x1) {
        VTSS_E("The expected value for sd_sd_stat tx_state was 0x1 but is 0x%x", value);
        rc = VTSS_RC_ERROR;
    } else {
        VTSS_D("Note: The value of sd_sd_stat tx_state was 0x%x", value);
    }

    REG_WRM(HSIO_SD_CFG(idx),
            HSIO_SD_CFG_TX_DATA_EN(1) |
            HSIO_SD_CFG_RX_DATA_EN(1),
            HSIO_SD_CFG_TX_DATA_EN_M |
            HSIO_SD_CFG_RX_DATA_EN_M);

/* Serdes 0 rx and tx now operational and enabled */

  return rc;
}

vtss_rc vtss_maserati_sd6g40_setup_lane(vtss_state_t *vtss_state, const vtss_sd6g40_setup_args_t config, u32 idx) {
    vtss_sd6g40_setup_struct_t calc_results;
    vtss_rc rc;
    VTSS_D("This function is generated with UTE based on TAG: temp");

    rc = vtss_calc_sd6g40_setup_lane(config, &calc_results);
    if(rc == VTSS_RC_OK) {
        rc |= vtss_maserati_sd6g40_reg_cfg(vtss_state, &calc_results, idx);
    }
    return rc;
}
#endif
#endif
